import json
from django.shortcuts import get_object_or_404, render
from rest_framework import status
from django.contrib import messages
from django.db import transaction
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework import generics
from exam.serializers.coursemanagementserializers import( DeleteQuestionSerializer, DeleteReadingMaterialSerializer, 
    DeleteSelectedCourseSerializer, DeleteSelectedQuizSerializer, 
    EditCourseInstanceSerializer, EditQuestionInstanceSerializer, EditQuizInstanceSerializer, 
    UploadReadingMaterialSerializer)
from custom_authentication.custom_mixins import ClientAdminMixin, ClientMixin, SuperAdminMixin
from exam.models.allmodels import (
    ActivityLog,
    Course,
    CourseEnrollment,
    CourseRegisterRecord,
    Notification,
    Quiz,
    Question,
    UploadReadingMaterial,
    UploadVideo
)
from rest_framework.exceptions import NotFound, ValidationError
from django.core.exceptions import ObjectDoesNotExist
from django.core.exceptions import PermissionDenied
from django.shortcuts import get_object_or_404, render, redirect
from django.utils.decorators import method_decorator
from exam.models.coremodels import *
from exam.serializers.courseserializers import *
from django.utils import timezone
from django.db.models import Q
from django.shortcuts import get_object_or_404, render
from rest_framework import status
from django.contrib import messages
from django.db import transaction
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import NotFound, ValidationError
from rest_framework import generics
from exam.models.allmodels import (
    Course,
    UploadVideo,
    UploadReadingMaterial,
    CourseStructure,
    CourseEnrollment,
    Quiz,
    Question,
)
from django.core.exceptions import PermissionDenied
from django.shortcuts import get_object_or_404, render, redirect
from django.utils.decorators import method_decorator
from exam.serializers.createcourseserializers import (
    ActivateCourseSerializer,
    CourseSerializer, 
    CourseStructureSerializer,
    CreateChoiceSerializer,
    InActivateCourseSerializer, 
    QuizSerializer, 
    CreateCourseSerializer,
    CreateUploadReadingMaterialSerializer,
)
import pandas as pd # type: ignore

filtered_display = ["active", "inactive", "all"]
class CourseView(SuperAdminMixin, ClientAdminMixin, ClientMixin, APIView): #(SuperAdminMixin, ClientAdminMixin, ClientMixin)
    
    """
    post : create version 1 course
        while creating instance :
                    # slug = auto generated by pre_save()
                    title = request body
                    summary = request body
                    created_at = updated_at = models.DateTimeField(auto_now=True)
                    active = False
                    original_course = null (as it is original course itself)
                    version_number = 1
    get : 
            if course_id : single instance details are shown (for all users)
                what will be displayed of selected course:
                    id
                    title,
                    summary,
                    updated_at,
                    original_course [title to be extracted on frontend],
                    version_number
            if filtered_display : 
                what will be displayed:
                    id
                    slug
                    title
                    created_at
                    updated_at
                    active
                    original_course 
                    version_number
                all -> list of all courses (super admin allowed only)
                active -> list of active courses (for all users)
                inactive -> list of inactive courses (super admin allowed only)
    """ 


    def get(self, request, *args, **kwargs):
        try:
            course_id = request.query_params.get('course_id')
            filtered_display = request.query_params.get('filtered_display')

            if not course_id or not filtered_display:
                return Response({"error": "Course ID is missing from query parameters."}, status=status.HTTP_400_BAD_REQUEST)

            if course_id:
                course = Course.objects.get(pk=course_id)
                if not course:
                    return Response({"error": "No course found with the provided ID."}, status=status.HTTP_404_NOT_FOUND)
                if course.deleted_at:
                    return Response({"error": "Access to deleted course is not allowed."}, status=status.HTTP_403_FORBIDDEN)
                serializer = CourseSerializer(course)
                return Response(serializer.data, status=status.HTTP_200_OK)

            if filtered_display:
                if filtered_display not in ["active", "inactive", "all"]:
                    return Response({"error": "Invalid filtered_display parameter"}, status=status.HTTP_400_BAD_REQUEST)
                
                queryset = Course.objects.filter(deleted_at__isnull=True).order_by('-created_at')
                
                if filtered_display == "active":
                    queryset = queryset.filter(active=True)
                elif filtered_display == "inactive":
                    if not self.has_super_admin_privileges(request):
                        return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
                    queryset = queryset.filter(active=False)
                elif filtered_display == "all":
                    if not self.has_super_admin_privileges(request):
                        return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
                    
                course_list = queryset.all()
                
                if not course_list.exists():
                    return Response({"message": "No course found.", "data": []}, status=status.HTTP_404_NOT_FOUND)
                serializer = CourseDisplaySerializer(course_list, many=True)
                return Response(serializer.data, status=status.HTTP_200_OK)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def post(self, request, *args, **kwargs):        
        try:
            if not self.has_super_admin_privileges(request):
                return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
            
            data = request.data
            if not data:
                return Response({"error": "Request body is empty"}, status=status.HTTP_400_BAD_REQUEST)
            serializer = CreateCourseSerializer(data=data)
            if serializer.is_valid():
                serializer.validated_data['active'] = False
                serializer.validated_data['original_course'] = None
                serializer.validated_data['version_number'] = 1
                course = serializer.save()
                return Response({"message": "Course created successfully", "course_id": course.pk}, status=status.HTTP_201_CREATED)
            else:
                return Response({"error": serializer.errors}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        
    def put(self, request, format=None):
        try:
            if not self.has_super_admin_privileges(request):
                return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)

            course_id = request.data.get('course_id')
            course = Course.objects.get(pk=course_id)
            
            if not course:
                raise Course.DoesNotExist("No course found with the provided course ID.")
            if course.deleted_at:
                raise ValidationError("Course instance has been deleted")
            
            serializer = EditCourseInstanceSerializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            course.title = serializer.validated_data.get('title')
            course.summary = serializer.validated_data.get('summary')
            course.updated_at = timezone.now()
            course.save()

            if course.active:
                latest_activity_log = ActivityLog.objects.latest('created_at')
                notification = Notification.objects.create(
                    message=latest_activity_log.message,
                    course=course
                )
                notification_data = {
                    "message": notification.message,
                    "created_at": notification.created_at
                }
                return Response({"message": "Course instance updated successfully", "notification": notification_data}, status=status.HTTP_200_OK)
            return Response({"message": "Course instance updated successfully"}, status=status.HTTP_200_OK)
        
        except Exception as e:
            error_message = str(e)
            if isinstance(e, (ValidationError, Course.DoesNotExist)):
                error_message = "Invalid data: " + error_message
            return Response({"error": error_message}, status=status.HTTP_400_BAD_REQUEST) 

    """  
    PATCH : This method soft-deletes a course instance based on the course_id provided in the request body.
    """

    def patch(self, request, format=None):
        try:
            if not self.has_super_admin_privileges(request):
                return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)

            serializer = DeleteSelectedCourseSerializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            course_id = serializer.validated_data['course_id']

            # Fetch the course instance
            course = Course.objects.get(id=course_id)

            # Check if the course is active
            if course.active:
                raise ValidationError("Course must be inactive before deletion.")

            # Soft delete the course
            course.active = False
            course.deleted_at = timezone.now()
            course.save()

            # Delete related instances if they are associated only with this course
            self.delete_related_instances(course)

            return Response({"message": "Course soft deleted successfully."}, status=status.HTTP_204_NO_CONTENT)
        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def delete_related_instances(self, course):
        # Delete mapped instances of course_id with reading material
        reading_materials = UploadReadingMaterial.objects.filter(courses=course)
        if reading_materials.exists():
            reading_materials.delete()

        # Delete mapped instances of course_id with video material
        video_materials = UploadVideo.objects.filter(courses=course)
        if video_materials.exists():
            video_materials.delete()

        # Delete mapped instances of course_id with quiz and associated questions
        quizzes = Quiz.objects.filter(courses=course)
        for quiz in quizzes:
            if quiz.questions.count() > 0:
                quiz.questions.all().delete()
            quiz.delete()


manage_status = ["activate", "inactivate","versioning"]
class ManageCourseView(SuperAdminMixin, APIView):
    """
        only accessible to super admin
        manage_status : 
            activate:
                if original_course field is null for this course_id 's instance:
                updating instance field:
                            change active from False to True
                if not null :
                        compare course structure for set of  (content_type , content_id) of course_id in url and id of course which is mentioned in original_course.
                        if match :
                                can't activate the course
                        if not match:
                                activate the course by changing active from False to True
            inactivate:
                do it by giving warning by counting the number of instances in course enrollment table where course_id is same as that in url and active is True. [to tell how many people are studying the course now]
                
                doing this : inactivating a course , it should be appearing for employees to study it or even register it any furthur customer,
                but the history of users regarding this course should not be erased.
                
                updating instance field:
                            change active from True to False
            versioning:
                on saving , new instance of course will be created :
                            slug = auto generated
                            title = same as course in url for now
                            summary = same as course in url for now
                            created_at = updated_at = now()
                            active = False
                            original_course = course id in url
                            version_number = count the instances for which course_id in url is originalcourse, and add 2 to that count, and pass it as version_number
                in course_structure table , taking the course_id from url, and id of newly created instance:
                        copy what is related to id in url to new instance.
                similarly for all reading material, video , quiz which are in relation with course_id in url , will be mapped with new instance too
    """
    def post(self, request, *args, **kwargs):
        try:
            if not self.has_super_admin_privileges(request):
                return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
            manage_status = request.data.get('manage_status')
            
            if manage_status not in ["activate", "inactivate","versioning"]:
                return Response({"error": "Invalid manage_status in request"}, status=status.HTTP_400_BAD_REQUEST)
            course_id = request.data.get('course_id')
            if not course_id:
                return Response({"error": "Course ID is missing"}, status=status.HTTP_400_BAD_REQUEST)
            if manage_status == "activate":
                return self.activate_course(course_id)
            elif manage_status == "inactivate":
                return self.inactivate_course(course_id)
            elif manage_status == "versioning":
                return self.create_course_derived_version(course_id)
        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def activate_course(self, course_id):
        try:
            course = Course.objects.get(pk=course_id, deleted_at__isnull=True)
            if not course:
                return Response({"error":"no course found"},status=status.HTTP_404_NOT_FOUND)
            serializer = ActivateCourseSerializer(data={'course_id': course.id})
            if serializer.is_valid():
                course = serializer.validated_data['course_id']
                if course.original_course is None:
                    course.active = True
                    course.save()
                    return Response({"message": "Course activated successfully."}, status=status.HTTP_200_OK)
                else:
                    original_course_structure = CourseStructure.objects.filter(course=course.original_course).values_list('content_type', 'content_id')
                    current_course_structure = CourseStructure.objects.filter(course=course).values_list('content_type', 'content_id')
                    if not original_course_structure or not current_course_structure:
                        return Response({"message":"Course Structure not found."}, status=status.HTTP_404_NOT_FOUND)

                    original_course_structure_df = pd.DataFrame(original_course_structure, columns=['content_type', 'content_id'])
                    current_course_structure_df = pd.DataFrame(current_course_structure, columns=['content_type', 'content_id'])

                    if original_course_structure_df.equals(current_course_structure_df):
                        return Response({"error": "Cannot activate the course. Course structure have exact match with original course."},
                                        status=status.HTTP_400_BAD_REQUEST)
                    else:
                        course.active = True
                        course.save()
                        return Response({"message": "Course activated successfully."}, status=status.HTTP_200_OK)
            else:
                return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def inactivate_course(self, course_id):
        try:
            serializer = InActivateCourseSerializer(data={'course_id': course_id})
            if serializer.is_valid():
                course = serializer.validated_data['course_id']
                active_enrollments_count = CourseEnrollment.objects.filter(course=course, active=True, deleted_at__isnull=True).count()
                if not active_enrollments_count:
                    return Response({"error":"no active course enrollment found"},status=status.HTTP_404_NOT_FOUND)
                course.active = False
                course.save()
                return Response({"message": "Course inactivated successfully.",
                                "active_enrollments_before_inactivation": active_enrollments_count},
                                status=status.HTTP_200_OK)
            else:
                return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
                
    def create_course_derived_version(self, course_id):
        try:
            original_course = Course.objects.get(pk=course_id)
            if not original_course.active:
                return Response({"error": "The original course is not active"}, status=status.HTTP_400_BAD_REQUEST)
            inactive_versions_count = Course.objects.filter(Q(original_course=original_course) & Q(active=False, deleted_at__isnull=True)).count()
            if inactive_versions_count >= 2:
                return Response(
                    {"error": "Two or more inactive versions of this course already exist. Delete or activate them first."},
                    status=status.HTTP_400_BAD_REQUEST)
        except Course.DoesNotExist:
            return Response({"error": "Original course not found."}, status=status.HTTP_404_NOT_FOUND)
        try:
            with transaction.atomic():
                # Create new course instance based on original course
                new_course_data = {
                    'title': original_course.title,
                    'summary': original_course.summary,
                    'active': False,
                    'original_course': original_course.id,
                    'created_at': timezone.now(),
                    'updated_at': timezone.now(),
                    'version_number': Course.objects.filter(original_course=original_course).count() + 2
                }
                new_course_serializer = CourseSerializer(data=new_course_data)
                if new_course_serializer.is_valid():
                    new_course = new_course_serializer.save()
                else:
                    return Response({"error": new_course_serializer.errors}, status=status.HTTP_400_BAD_REQUEST)
                
                # Copy course structure from original course
                original_course_structure = CourseStructure.objects.filter(course=original_course)
                if not original_course_structure:
                    return Response({"error": "The original course structure not found"}, status=status.HTTP_404_NOT_FOUND)
                for structure in original_course_structure:
                    structure_data = CourseStructureSerializer(structure).data
                    structure_data['course'] = new_course.pk
                    structure_serializer = CourseStructureSerializer(data=structure_data)
                    if structure_serializer.is_valid():
                        structure_serializer.save()
                    else:
                        return Response({"error": structure_serializer.errors}, status=status.HTTP_400_BAD_REQUEST)
                
                related_reading_materials = UploadReadingMaterial.objects.filter(courses=original_course)
                if related_reading_materials:
                    new_course.reading_materials.set(related_reading_materials)
                    
                # Map existing UploadVideo
                related_videos = UploadVideo.objects.filter(courses=original_course)
                if related_videos:
                    new_course.video_materials.set(related_videos)
                    
                # Map existing Quiz
                related_quizzes = Quiz.objects.filter(courses=original_course)
                if related_quizzes:
                    new_course.quizzes.set(related_quizzes)
            return Response({"message": "New version of course created successfully."}, status=status.HTTP_201_CREATED)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class CourseStructureView(SuperAdminMixin, ClientAdminMixin, ClientMixin, APIView):
    """
        get: to retrieve the course structure of course in url (for authorized all)
        post: to create course structure instances for course in url (for super admin only)
    """

    def get(self, request, course_id, format=None):
        try:
            course_structures = CourseStructure.objects.filter(course_id=course_id, active=True, deleted_at__isnull=True)
            if course_structures.exists():
                serializer = CourseStructureSerializer(course_structures, many=True)
                return Response(serializer.data, status=status.HTTP_200_OK)
            else:
                return Response({"error": "No course structures found for the specified course ID"}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def post(self, request, course_id, *args, **kwargs):

        if not self.has_super_admin_privileges(request):
            return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
        # Check if course exists
        course = Course.objects.get(pk=course_id)
        if not course:
            return Response({"error": "Course not found"}, status=status.HTTP_404_NOT_FOUND)
        # Check if the course is active
        if course.active:
            return Response({"error": "Course is active, cannot proceed"}, status=status.HTTP_403_FORBIDDEN)
        try:
            # Extract data from request body
            order_numbers = request.data.get('order_number', [])
            content_types = request.data.get('content_type', [])
            content_ids = request.data.get('content_id', [])
            
            # Check if lengths of lists are same
            if len(order_numbers) != len(content_types) or len(content_types) != len(content_ids):
                return Response({"error": "Length of order_number, content_type, and content_id lists must be the same"}, status=status.HTTP_400_BAD_REQUEST)
            
            # Create CourseStructure instances
            new_created_course_structure = []
            course_structure_data = []
            existing_course_structure_data = []
            edited_existing_course_structure_data = []
            
            for order_number, content_type, content_id in zip(order_numbers, content_types, content_ids):
                # Check if an instance with similar course_id, content_type, content_id, and order_number exists
                instance_exists = CourseStructure.objects.filter(course=course_id, content_type=content_type, content_id=content_id, order_number=order_number).exists()
                if instance_exists:
                    data = {
                        'course': course_id,
                        'order_number': order_number,
                        'content_type': content_type,
                        'content_id': content_id
                    }
                    existing_course_structure_data.append(data)
                    course_structure_data.append(data)
                    # Skip mapping this instance
                    continue
                
                # Check if there's an existing instance with the same content_id and content_type but different order_number
                existing_instance = CourseStructure.objects.filter(course=course_id, content_type=content_type, content_id=content_id).first()
                if existing_instance:
                    # Update the order_number
                    existing_instance.order_number = order_number
                    existing_instance.save()
                    data = {
                        'course': course_id,
                        'order_number': order_number,
                        'content_type': content_type,
                        'content_id': content_id
                    }
                    edited_existing_course_structure_data.append(data)
                    course_structure_data.append(data)
                else:
                    # Create a new instance
                    data = {
                        'course': course_id,
                        'order_number': order_number,
                        'content_type': content_type,
                        'content_id': content_id
                    }
                    new_created_course_structure.append(data)
                    course_structure_data.append(data)
            
            # Save new instances
            serializer = CourseStructureSerializer(data=new_created_course_structure, many=True)
            if serializer.is_valid():
                serializer.save()
                return Response({"message": "Course structure created successfully", 
                                "existing_record": existing_course_structure_data,
                                "edited_records" : edited_existing_course_structure_data,
                                "new_records": new_created_course_structure,
                                "all_record": course_structure_data
                                }, status=status.HTTP_201_CREATED)
            else:
                return Response({"error": serializer.errors}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class ReadingMaterialView(SuperAdminMixin, ClientAdminMixin, ClientMixin, APIView):
    """
        get: to retrieve the reading material of course in url (for authorized all)
        post: to create reading material instances for course in url (for super admin only)
    """
    
    def get(self, request, course_id, format=None):
        
        try:
            # user = request.user
                # =================================================================
            user_header = request.headers.get("user")
            if user_header:
                user = json.loads(user_header)
                customer_id = user.get("customer")
                # =================================================================
            actively_enrolled = CourseEnrollment.objects.filter(course=course_id, user=user.id, active=True).exists()
            actively_registered = CourseRegisterRecord.objects.filter(course=course_id, customer=user.customer.id, active=True).exists()
            if not self.has_super_admin_privileges(request) or not actively_enrolled or not actively_registered :
                return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
            
            content_id = request.query_params.get('content_id')
            list_mode = request.query_params.get('list', '').lower() == 'true'  # Check if list mode is enabled
            if content_id:
                reading_material = UploadReadingMaterial.objects.get(
                    courses__id=course_id, 
                    id=content_id, 
                    active=True, 
                    deleted_at__isnull=True
                    )
                if reading_material :
                    serializer = ReadingMaterialSerializer(reading_material)
                    return Response(serializer.data, status=status.HTTP_200_OK)
            elif list_mode:
                reading_materials = UploadReadingMaterial.objects.filter(
                    courses__id=course_id, 
                    active=True, 
                    deleted_at__isnull=True
                )
                serializer = ReadingMaterialListPerCourseSerializer(reading_materials, many=True)
                return Response(serializer.data, status=status.HTTP_200_OK)
            else:
                return Response({"error": "Specify 'content_id' or enable 'list' mode in query parameters."}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def post(self, request, course_id, *args, **kwargs):
        
        if not self.has_super_admin_privileges(request):
            return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
        course = Course.objects.get(pk=course_id)
        if not course:
            return Response({"error": "Course not found"}, status=status.HTTP_404_NOT_FOUND)
        if course.active:
            return Response({"error": "Course is active, cannot proceed"}, status=status.HTTP_403_FORBIDDEN)

        data = request.data
        if not data:
            return Response({"error": "Request body is empty"}, status=status.HTTP_400_BAD_REQUEST)

        try:
            serializer = CreateUploadReadingMaterialSerializer(data=data)
            if serializer.is_valid():
                # Set additional fields
                serializer.validated_data['courses'] = [course_id]
                reading_material = serializer.save()
                # If original_course is null, only save reading material
                if course.original_course is None:
                    return Response({"message": "Reading material created successfully"}, status=status.HTTP_201_CREATED)
                else:
                    # If original_course is not null, also create a CourseStructure entry
                    try:
                        last_order_number = CourseStructure.objects.filter(course=course).latest('order_number').order_number
                    except CourseStructure.DoesNotExist:
                        last_order_number = 0
                    # Create new CourseStructure instance
                    course_structure_data = {
                        'course': course_id,
                        'order_number': last_order_number + 1,
                        'content_type': 'reading',
                        'content_id': reading_material.pk
                    }
                    course_structure_serializer = CourseStructureSerializer(data=course_structure_data)
                    if course_structure_serializer.is_valid():
                        course_structure_serializer.save()
                        return Response({"message": "Reading material created successfully"}, status=status.HTTP_201_CREATED)
                    else:
                        return Response({"error": course_structure_serializer.errors}, status=status.HTTP_400_BAD_REQUEST)
            else:
                return Response({"error": serializer.errors}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
                
    def put(self, request, course_id, format=None):
        try:
            if not self.has_super_admin_privileges(request):
                return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)

            reading_material_id = request.data.get('reading_material_id')
            
            if reading_material_id is None:
                return Response({"error": "reading_material_id is required in the request body."},
                                status=status.HTTP_400_BAD_REQUEST)
            
            with transaction.atomic():
                # Get the reading material instance
                reading_material = get_object_or_404(UploadReadingMaterial, pk=reading_material_id)
                
                # Check if the associated course is active
                if reading_material.courses.filter(pk=course_id, active=True).exists():
                    return Response({"error": "Cannot edit reading material. Course is active."},
                                    status=status.HTTP_403_FORBIDDEN)

                # Validate request data
                serializer = UploadReadingMaterialSerializer(instance=reading_material, data=request.data, partial=True)
                serializer.is_valid(raise_exception=True)
                serializer.save(updated_at=timezone.now())

                return Response(serializer.data, status=status.HTTP_200_OK)

        except Exception as e:
            error_message = str(e)
            if isinstance(e, (UploadReadingMaterial.DoesNotExist, ValidationError)):
                error_message = "Reading material not found." if isinstance(e, UploadReadingMaterial.DoesNotExist) else str(e)
                status_code = status.HTTP_404_NOT_FOUND
            else:
                status_code = status.HTTP_500_INTERNAL_SERVER_ERROR

            return Response({"error": error_message}, status=status_code)
    
    def patch(self, request, course_id, format=None):
        try:
            if not self.has_super_admin_privileges(request):
                return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)

            reading_material_id = request.data.get('reading_material_id')
            
            if reading_material_id is None:
                return Response({"error": "reading_material_id is required in the request body."},
                                status=status.HTTP_400_BAD_REQUEST)
            
            # Fetch the reading material instance
            reading_material = get_object_or_404(UploadReadingMaterial, pk=reading_material_id)
            
            # Validate request data
            serializer = DeleteReadingMaterialSerializer(data=request.data)
            serializer.is_valid(raise_exception=True)
            
            with transaction.atomic():
                # Check if the reading material is associated with other courses
                other_courses_count = reading_material.courses.exclude(id=course_id).count()
                if other_courses_count > 0:
                    # Only remove the relation with the current course
                    reading_material.courses.remove(course_id)
                else:
                    # No other courses are associated, soft delete the reading material
                    reading_material.deleted_at = timezone.now()
                    reading_material.active = False
                    reading_material.save()
                
                return Response({"message": "Reading material deleted successfully."}, status=status.HTTP_204_NO_CONTENT)
        
        except Exception as e:
            error_message = str(e)
            if isinstance(e, (UploadReadingMaterial.DoesNotExist, ValidationError)):
                error_message = "Reading material not found." if isinstance(e, UploadReadingMaterial.DoesNotExist) else str(e)
                status_code = status.HTTP_404_NOT_FOUND
            else:
                status_code = status.HTTP_500_INTERNAL_SERVER_ERROR

            return Response({"error": error_message}, status=status_code)


class QuizView(SuperAdminMixin, ClientAdminMixin, ClientMixin,APIView):
    """
        get: to retrieve the quiz of course in url (for authorized all)
        post: to create quiz instances for course in url (for super admin only)
    """
    def get(self, request, course_id,format=None):
        try:
            
            content_id = request.query_params.get('content_id')
            list_mode = request.query_params.get('list', '').lower() == 'true'  # Check if list mode is enabled
            if content_id:
                # user = request.user
                    # =================================================================
                user_header = request.headers.get("user")
                if user_header:
                    user = json.loads(user_header)
                    customer_id = user.get("customer")
                    # =================================================================
                actively_enrolled = CourseEnrollment.objects.filter(course=course_id, user=user.id, active=True).exists()
                actively_registered = CourseRegisterRecord.objects.filter(course=course_id, customer=user.customer.id, active=True).exists()
                if not self.has_super_admin_privileges(request) or not actively_enrolled or not actively_registered :
                    return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
                quiz = Quiz.objects.get(
                    courses__id=course_id, 
                    id=content_id, 
                    active=True, 
                    deleted_at__isnull=True
                    )
                if quiz:
                    serializer = QuizSerializer(quiz)
                    return Response(serializer.data, status=status.HTTP_200_OK)
                else:
                    return Response({"error": "No quiz found for the specified ID"}, status=status.HTTP_404_NOT_FOUND)
            elif list_mode:
                if not self.has_super_admin_privileges(request):
                    return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
                quizzes = Quiz.objects.filter(
                    courses__id=course_id, 
                    active=True, 
                    deleted_at__isnull=True
                )
                serializer = QuizListPerCourseSerializer(quizzes, many=True)
                return Response(serializer.data, status=status.HTTP_200_OK)
            else:
                return Response({"error": "Specify 'content_id' or enable 'list' mode in query parameters."}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def post(self, request, course_id, *args, **kwargs):
        if not self.has_super_admin_privileges(request):
            return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
        course = Course.objects.get(pk=course_id)
        if not course:
            return Response({"error": "Course not found"}, status=status.HTTP_404_NOT_FOUND)
        if course.active:
            return Response({"error": "Course is active, cannot proceed"}, status=status.HTTP_403_FORBIDDEN)

        data = request.data
        if not data:
            return Response({"error": "Request body is empty"}, status=status.HTTP_400_BAD_REQUEST)
        try:
            # Validate and save quiz
            requested_data = request.data.copy()
            requested_data['courses'] = [course_id]
            serializer = QuizSerializer(data=requested_data)
            if serializer.is_valid():
                quiz = serializer.save()
                # If original_course is null, only save quiz
                if course.original_course is None:
                    return Response({"message": "Quiz created successfully"}, status=status.HTTP_201_CREATED)
                else:
                    # If original_course is not null, also create a CourseStructure entry
                    try:
                        last_order_number = CourseStructure.objects.filter(course=course).latest('order_number').order_number
                    except CourseStructure.DoesNotExist:
                        last_order_number = 0
                    # Create new CourseStructure instance
                    course_structure_data = {
                        'course': course_id,
                        'order_number': last_order_number + 1,
                        'content_type': 'quiz',
                        'content_id': quiz.pk
                    }
                    course_structure_serializer = CourseStructureSerializer(data=course_structure_data)
                    if course_structure_serializer.is_valid():
                        course_structure_serializer.save()
                        return Response({"message": "Quiz created successfully"}, status=status.HTTP_201_CREATED)
                    else:
                        return Response({"error": course_structure_serializer.errors}, status=status.HTTP_400_BAD_REQUEST)
            else:
                return Response({"error": serializer.errors}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def put(self, request, course_id, format=None):
        try:
            if not self.has_super_admin_privileges(request):
                return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
            
            # Check if course exists
            course = Course.objects.get(pk=course_id)
            if course.active:
                return Response({"error": "Editing is not allowed for active courses."},
                                status=status.HTTP_403_FORBIDDEN)

            # Check if quiz exists
            quiz_id = request.data.get('quiz_id', None)
            if not quiz_id:
                return Response({"error": "Quiz ID is required in the request body."}, status=status.HTTP_400_BAD_REQUEST)
            quiz = Quiz.objects.get(pk=quiz_id)
            if course not in quiz.courses.all():
                return Response({"error": "Quiz not found for the specified course."},
                                status=status.HTTP_404_NOT_FOUND)

            # Update quiz instance
            serializer = EditQuizInstanceSerializer(quiz, data=request.data, partial=True)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data, status=status.HTTP_200_OK)

        except ObjectDoesNotExist as e:
            error_message = "Resource not found" if isinstance(e, ObjectDoesNotExist) else str(e)
            status_code = status.HTTP_404_NOT_FOUND if isinstance(e, ObjectDoesNotExist) else status.HTTP_500_INTERNAL_SERVER_ERROR
            return Response({"error": error_message}, status=status_code)
    
    def patch(self, request, course_id, format=None):
        try:
            if not self.has_super_admin_privileges(request):
                return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
            
            quiz_id = request.data.get('quiz_id', None)
            if not quiz_id:
                return Response({"error": "Quiz ID is required in the request body."}, status=status.HTTP_400_BAD_REQUEST)
            
            # Validate request data
            serializer = DeleteSelectedQuizSerializer(data={'quiz_id': quiz_id})
            serializer.is_valid(raise_exception=True)
            
            # Fetch the quiz instance
            quiz = Quiz.objects.get(id=quiz_id)
            
            # Check if the quiz is associated with other courses
            other_courses_count = quiz.courses.exclude(id=course_id).count()
            if other_courses_count > 0:
                # Only remove the relation with the current course
                quiz.courses.remove(course_id)
            else:
                # No other courses are associated, soft delete the quiz
                quiz.deleted_at = timezone.now()
                quiz.active = False
                quiz.save()
                
            return Response({"message": "Quiz deleted successfully."}, status=status.HTTP_204_NO_CONTENT)

        except ObjectDoesNotExist as e:
            error_message = "Quiz not found" if isinstance(e, ObjectDoesNotExist) else "Internal Server Error"
            status_code = status.HTTP_404_NOT_FOUND if isinstance(e, ObjectDoesNotExist) else status.HTTP_500_INTERNAL_SERVER_ERROR
            return Response({"error": error_message}, status=status_code)


class QuestionView(SuperAdminMixin, APIView):
    
    """
        post: to create question instances for course in url (for super admin only)
    """
    def get(self, request, quiz_id, format=None):
        try:
            if not self.has_super_admin_privileges(request) :
                return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
            questions = Question.objects.filter(
                quizzes__id=quiz_id, 
                active=True, 
                deleted_at__isnull=True
            )
            serializer = QuestionListPerQuizSerializer(questions, many=True)
            return Response(serializer.data, status=status.HTTP_200_OK)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        
    def post(self, request, course_id, *args, **kwargs):
        if not self.has_super_admin_privileges(request) :
            return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
        course = Course.objects.get(pk=course_id)
        if not course:
            return Response({"error": "Course not found"}, status=status.HTTP_404_NOT_FOUND)
        if course.active:
            return Response({"error": "Course is active, cannot proceed"}, status=status.HTTP_403_FORBIDDEN)

        data = request.data
        if not data:
            return Response({"error": "Request body is empty"}, status=status.HTTP_400_BAD_REQUEST)
        try:
            # Validate and save quiz
            requested_data = request.data.copy()
            requested_data['courses'] = [course_id]
            serializer = QuizSerializer(data=requested_data)
            if serializer.is_valid():
                quiz = serializer.save()
                # If original_course is null, only save quiz
                if course.original_course is None:
                    return Response({"message": "Quiz created successfully"}, status=status.HTTP_201_CREATED)
                else:
                    # If original_course is not null, also create a CourseStructure entry
                    try:
                        last_order_number = CourseStructure.objects.filter(course=course).latest('order_number').order_number
                    except CourseStructure.DoesNotExist:
                        last_order_number = 0
                    # Create new CourseStructure instance
                    course_structure_data = {
                        'course': course_id,
                        'order_number': last_order_number + 1,
                        'content_type': 'quiz',
                        'content_id': quiz.pk
                    }
                    course_structure_serializer = CourseStructureSerializer(data=course_structure_data)
                    if course_structure_serializer.is_valid():
                        course_structure_serializer.save()
                        return Response({"message": "Quiz created successfully"}, status=status.HTTP_201_CREATED)
                    else:
                        return Response({"error": course_structure_serializer.errors}, status=status.HTTP_400_BAD_REQUEST)
            else:
                return Response({"error": serializer.errors}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def put(self, request, quiz_id, format=None):  
        error_response = None
        try:
            if not self.has_super_admin_privileges(request):
                return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
            
            # Extract question_id from request body
            question_id = request.data.get('question_id')
            if not question_id:
                raise ValidationError("Question ID is required in the request body.")

            # Extract course_id from request body
            course_id = request.data.get('course_id')
            if not course_id:
                raise ValidationError("Course ID is required in the request body.")

            # Check if quiz exists
            quiz = Quiz.objects.get(pk=quiz_id)

            # Check if question exists
            question = Question.objects.get(pk=question_id)
            if quiz not in question.quizzes.all():
                raise ValidationError("Question not found for the specified quiz.")

            # Check if course exists
            course = Course.objects.get(pk=course_id)
            if course.active:
                error_response = {"error": "Editing is not allowed for active courses."}
            elif course not in quiz.courses.all():
                error_response = {"error": "Quiz not found for the specified course."}
            else:
                # Update question instance
                serializer = EditQuestionInstanceSerializer(question, data=request.data, partial=True)
                serializer.is_valid(raise_exception=True)
                serializer.save()
                return Response(serializer.data, status=status.HTTP_200_OK)

        except ValidationError as e:
            error_response = {"error": str(e)}
        
        if error_response:
            return Response(error_response, status=status.HTTP_400_BAD_REQUEST)

        # Handle other unexpected errors
        return Response({"error": "An unexpected error occurred."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


    def patch(self, request, quiz_id, format=None):
        error_response = None
        try:
            if not self.has_super_admin_privileges(request):
                return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
            
            # Validate request data
            serializer = DeleteQuestionSerializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            # Extract validated question_id
            question_id = serializer.validated_data['question_id']
            
            # Fetch the question instance
            question = Question.objects.get(id=question_id)

            # Check if the question is associated with the specified quiz
            if quiz_id not in question.quizzes.values_list('id', flat=True):
                error_response = {"error": "Question not found for the specified quiz."}
            else:
                # Check if the question is associated with other quizzes
                other_quizzes_count = question.quizzes.exclude(id=quiz_id).count()
                if other_quizzes_count > 0:
                    # Only remove the relation with the current quiz
                    question.quizzes.remove(quiz_id)
                else:
                    # No other quizzes are associated, soft delete the question
                    question.deleted_at = timezone.now()
                    question.active = False
                    question.save()

                return Response({"message": "Question deleted successfully."}, status=status.HTTP_204_NO_CONTENT)

        except ObjectDoesNotExist:
            error_response = {"error": "Question not found."}

        if error_response:
            return Response(error_response, status=status.HTTP_404_NOT_FOUND)

        # Handle other unexpected errors
        return Response({"error": "An unexpected error occurred."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    
class ChoicesView(SuperAdminMixin, APIView):
    
    """
        post: to create choice instances for course in url (for super admin only)
    """
    def post(self, request, question_id, *args, **kwargs):
        if not self.has_super_admin_privileges(request) :
            return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
        question = Question.objects.get(pk=question_id)
        if not question:
            return  Response({"error": "Question not found"}, status=status.HTTP_404_NOT_FOUND)
        try:
            serializer = CreateChoiceSerializer(data=request.data, context={'question_id': question_id})
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)